package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"gopkg.in/yaml.v3"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"
)

// EntityConfig defines which OpenAPI types should become GORM entities
type EntityConfig struct {
	Name          string            // DTO type name from OpenAPI
	TableName     string            // Optional custom table name
	PKField       string            // Primary key field (default: "ID")
	SoftDelete    bool              // Add DeletedAt
	Indexes       []string          // Fields to index
	UniqueIndexes []string          // Fields with unique indexes
	GormIndexes   []GormIndexConfig // Custom GORM indexes parsed from OpenAPI x-go-gorm-index
	Fields        []FieldConfig
	// Flag indicating whether the original DTO contains CreatedAt and UpdatedAt
	DtoHasDates bool
}

// GormIndexConfig represents a single GORM index definition
type GormIndexConfig struct {
	Name   string   `yaml:"name"`
	Unique bool     `yaml:"unique"`
	Fields []string `yaml:"fields"`
}

type FieldConfig struct {
	Name         string
	TypeExpr     string // Rendered Go type for entity field
	IsSimple     bool   // If false, add gorm serializer:json
	IsFKField    bool   // True if this is a foreign key field (excluded from DTO)
	GormTag      string // Custom GORM tag
	IsEntityRef  bool   // True if this references another entity (needs .DTO() conversion)
	OriginalType string // Original DTO type for conversion
	Comment      string // Field comment/description copied from DTO
}

const tmpl = `// Code generated by genentities. DO NOT EDIT.
package entities

import (
	"gorm.io/gorm"
	"viz/internal/dto"
	"time"
)

{{range .Entities}}
// {{.Name}} is a GORM entity inferred from dto.{{.Name}}
type {{.Name}} struct {
	{{if .PKField}}{{.PKField}} uint ` + "`gorm:\"primarykey\" json:\"-\"`" + `{{end}}
	{{if .SoftDelete}}DeletedAt gorm.DeletedAt ` + "`gorm:\"index\" json:\"-\"`" + `{{end}}
	CreatedAt time.Time
	UpdatedAt time.Time
	{{- range .Fields}}
	{{- if .Comment}}
	{{- $lines := splitLines .Comment}}
	{{- range $i, $line := $lines}}
	// {{$line}}
	{{- end}}
	{{- end}}
	{{.Name}} {{.TypeExpr}}{{if .GormTag}} ` + "`{{.GormTag}}`" + `{{else if not .IsSimple}} ` + "`gorm:\"serializer:json;type:JSONB\"`" + `{{end}}
	{{- end}}
}

func (e {{.Name}}) DTO() dto.{{.Name}} {
	return dto.{{.Name}}{
		{{- if .DtoHasDates}}
		CreatedAt: e.CreatedAt,
		UpdatedAt: e.UpdatedAt,
		{{- end}}
		{{- range .Fields}}
		{{- if not .IsFKField}}
		{{- if .IsEntityRef}}
		{{.Name}}: func() *dto.{{.OriginalType}} { if e.{{.Name}} != nil { d := e.{{.Name}}.DTO(); return &d }; return nil }(),
		{{- else}}
		{{.Name}}: e.{{.Name}},
		{{- end}}
		{{- end}}
		{{- end}}
	}
}

func {{.Name}}FromDTO(d dto.{{.Name}}) {{.Name}} {
	return {{.Name}}{
		{{- if .DtoHasDates}}
		CreatedAt: d.CreatedAt,
		UpdatedAt: d.UpdatedAt,
		{{- end}}
		{{- range .Fields}}
		{{- if not .IsFKField}}
		{{- if .IsEntityRef}}
		{{.Name}}ID: func() *string { if d.{{.Name}} != nil { return &d.{{.Name}}.Uid }; return nil }(),
		{{- else}}
		{{.Name}}: d.{{.Name}},
		{{- end}}
		{{- end}}
		{{- end}}
	}
}

{{end}}
`

type templateData struct {
	Entities []EntityConfig
}

func main() {
	dtoFile := flag.String("dto", "internal/dto/types.gen.go", "Path to generated DTO file")
	outFile := flag.String("o", "internal/entities/generated.go", "Output file path")
	include := flag.String("include", "", "Comma-separated DTO type names to force-include as entities (use as last resort)")
	openapiPath := flag.String("openapi", "", "Path to OpenAPI spec (yaml/json)")
	flag.Parse()

	// Discover entities
	discovered, err := discoverEntities(*dtoFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to discover entities: %v\n", err)
		os.Exit(1)
	}

	// If an OpenAPI spec path was provided, parse it and collect x-entity:true schema names.
	openapiIncludes := map[string]EntityConfig{}
	if *openapiPath != "" {
		data, err := os.ReadFile(*openapiPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to read OpenAPI file '%s': %v\n", *openapiPath, err)
			os.Exit(1)
		}

		var doc map[string]any
		if err := yaml.Unmarshal(data, &doc); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to parse OpenAPI YAML: %v\n", err)
			os.Exit(1)
		}

		openapiIncludes = extractOpenAPIEntities(doc)
	}

	// for DTOs we want to explicitly define as entities (CLI -include has lowest priority)
	if *include != "" {
		for name := range strings.SplitSeq(*include, ",") {
			name = strings.TrimSpace(name)
			if name == "" {
				continue
			}
			// Assign a basic EntityConfig, as this is a force-include via CLI
			openapiIncludes[name] = EntityConfig{
				Name:       name,
				SoftDelete: true,
				PKField:    "ID",
			}
		}
	}
	// Merge OpenAPI includes into discovered entities (OpenAPI preference)
	if len(openapiIncludes) > 0 {
		var mergedDiscovered []EntityConfig
		// Create a map for faster lookup of discovered entities by name
		discoveredMap := make(map[string]EntityConfig)
		for _, e := range discovered {
			discoveredMap[e.Name] = e
		}

		for name, openapiConf := range openapiIncludes {
			if existing, found := discoveredMap[name]; found {
				// Merge existing with openapiConf, giving openapiConf precedence for GormIndexes
				if len(openapiConf.GormIndexes) > 0 {
					existing.GormIndexes = openapiConf.GormIndexes
				}
				// Other fields can also be merged/overwritten if necessary
				mergedDiscovered = append(mergedDiscovered, existing)
				delete(discoveredMap, name) // Remove from map so it's not added again
			} else {
				// If not found in discovered, add the openapiConf directly
				mergedDiscovered = append(mergedDiscovered, openapiConf)
			}
		}

		// Add any remaining discovered entities that were not in openapiIncludes
		for _, e := range discoveredMap {
			mergedDiscovered = append(mergedDiscovered, e)
		}
		discovered = mergedDiscovered
	}

	// Infer fields for each entity
	entities, err := populateEntityFields(*dtoFile, discovered)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to analyze DTO fields: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Auto-discovered %d entities: ", len(entities))
	for i, e := range entities {
		if i > 0 {
			fmt.Print(", ")
		}
		fmt.Print(e.Name)
	}
	fmt.Println()

	t := template.Must(template.New("entities").Funcs(template.FuncMap{
		"splitLines": func(s string) []string {
			s = strings.ReplaceAll(s, "\r\n", "\n")
			return strings.Split(s, "\n")
		},
	}).Parse(tmpl))

	var buf bytes.Buffer
	if err := t.Execute(&buf, templateData{Entities: entities}); err != nil {
		fmt.Fprintf(os.Stderr, "Template execution failed: %v\n", err)
		os.Exit(1)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to format generated code: %v\n", err)
		os.Exit(1)
	}

	if err := os.MkdirAll(filepath.Dir(*outFile), 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create output directory: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(*outFile, formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to write output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated GORM entities in %s\n", *outFile)
}

// discoverEntities parses the DTO file and finds types that look like entities.
// Heuristic: structs with `uid`, `created_at`, and `updated_at` fields are treated as entities.
func discoverEntities(dtoPath string) ([]EntityConfig, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, dtoPath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parse DTO file: %w", err)
	}

	var entities []EntityConfig

	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// Analyze struct fields to see if it matches entity pattern
		hasUID := false
		hasCreatedAt := false
		hasUpdatedAt := false
		var uniqueIndexes []string

		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue
			}
			fieldName := field.Names[0].Name
			lowerName := strings.ToLower(fieldName)

			if lowerName == "uid" {
				hasUID = true
				uniqueIndexes = append(uniqueIndexes, fieldName)
			}
			if lowerName == "createdat" {
				hasCreatedAt = true
			}
			if lowerName == "updatedat" {
				hasUpdatedAt = true
			}
		}

		// If it has a UID, treat it as an entity candidate.
		// CreatedAt/UpdatedAt are optional (GORM-managed) but if present they further indicate an entity.
		if hasUID {
			entities = append(entities, EntityConfig{
				Name:          typeSpec.Name.Name,
				SoftDelete:    true,
				UniqueIndexes: uniqueIndexes,
				PKField:       "ID",
				DtoHasDates:   hasCreatedAt && hasUpdatedAt,
			})
		}

		return true
	})

	return entities, nil
}

// populateEntityFields inspects the DTO structs for each entity and infers field types and JSON storage.
func populateEntityFields(dtoPath string, entities []EntityConfig) ([]EntityConfig, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, dtoPath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parse DTO file: %w", err)
	}

	// Build map of name -> *ast.StructType
	structMap := map[string]*ast.StructType{}
	ast.Inspect(node, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}
		st, ok := ts.Type.(*ast.StructType)
		if !ok {
			return true
		}
		structMap[ts.Name.Name] = st
		return true
	})

	isBasic := func(name string) bool {
		switch name {
		case "string", "bool", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64":
			return true
		default:
			return false
		}
	}

	// Discover simple type aliases (e.g. `type UserRole string`) so we can treat them as simple/basic
	aliasMap := map[string]string{}
	for _, decl := range node.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			tspec := spec.(*ast.TypeSpec)
			if ident, ok := tspec.Type.(*ast.Ident); ok {
				if isBasic(ident.Name) {
					aliasMap[tspec.Name.Name] = ident.Name
				}
			}
		}
	}

	var renderType func(expr ast.Expr) (string, bool)
	renderType = func(expr ast.Expr) (typeStr string, simple bool) {
		switch t := expr.(type) {
		case *ast.Ident:
			if isBasic(t.Name) {
				return t.Name, true
			}
			if t.Name == "Time" {
				return "time.Time", true
			}
			return "dto." + t.Name, false
		case *ast.StarExpr:
			inner, s := renderType(t.X)
			// pointer to dto or composite becomes non-simple
			if strings.HasPrefix(inner, "dto.") || strings.HasPrefix(inner, "[]") || strings.HasPrefix(inner, "map[") {
				return "*" + inner, false
			}
			return "*" + inner, s
		case *ast.ArrayType:
			elt, _ := renderType(t.Elt)
			return "[]" + elt, false
		case *ast.SelectorExpr:
			if x, ok := t.X.(*ast.Ident); ok && x.Name == "time" && t.Sel.Name == "Time" {
				return "time.Time", true
			}
			return "dto." + t.Sel.Name, false
		case *ast.MapType:
			key, _ := renderType(t.Key)
			val, _ := renderType(t.Value)
			return "map[" + key + "]" + val, false
		default:
			return "any", false
		}
	}

	// Build entities with fields
	for i, e := range entities {
		st := structMap[e.Name]
		if st == nil {
			continue
		}
		var fields []FieldConfig
		for _, f := range st.Fields.List {
			if len(f.Names) == 0 {
				continue
			}
			name := f.Names[0].Name
			lowerName := strings.ToLower(name)

			// Capture any comment or doc string attached to the DTO field
			comment := ""
			if f.Doc != nil {
				comment = strings.TrimSpace(f.Doc.Text())
			} else if f.Comment != nil {
				comment = strings.TrimSpace(f.Comment.Text())
			}

			// Skip GORM-managed timestamp fields - GORM will handle these automatically
			if lowerName == "createdat" || lowerName == "updatedat" {
				continue
			}

			// Extract JSON key from struct tag
			jsonName := ""
			if f.Tag != nil {
				// We manually parse because we don't want to reflect on types we don't have loaded
				tagContent := strings.Trim(f.Tag.Value, "`")
				for tagPart := range strings.SplitSeq(tagContent, " ") {
					if after, ok :=strings.CutPrefix(tagPart, "json:\""); ok  {
						val := after
						val = strings.TrimSuffix(val, "\"")
						// Handle json:"name,omitempty"
						if commaIdx := strings.Index(val, ","); commaIdx != -1 {
							val = val[:commaIdx]
						}
						jsonName = val
						break
					}
				}
			}

			tStr, simple := renderType(f.Type)

			// If this field is an identifier that is an alias to a basic type (e.g. UserRole -> string),
			// treat it as simple and prefer a text GORM column instead of JSONB.
			if ident, ok := f.Type.(*ast.Ident); ok {
				if base, exists := aliasMap[ident.Name]; exists {
					if base == "string" {
						simple = true
					}
				}
			}

			// Special handling for references to other entities
			// If field type is *dto.SomeType and SomeType has a uid field, treat it as a foreign key
			if after, ok :=strings.CutPrefix(tStr, "*dto."); ok  {
				typeName := after
				if refStruct, exists := structMap[typeName]; exists {
					// Check if this referenced type has a uid field (making it an entity)
					hasUID := false
					for _, refField := range refStruct.Fields.List {
						if len(refField.Names) > 0 && strings.ToLower(refField.Names[0].Name) == "uid" {
							hasUID = true
							break
						}
					}
					if hasUID {
						// Add foreign key field (excluded from DTO)
						fields = append(fields, FieldConfig{
							Name:      name + "ID",
							TypeExpr:  "*string",
							IsSimple:  true,
							IsFKField: true,
						})
						// Add relationship field - reference the entity type, not DTO
						fields = append(fields, FieldConfig{
							Name:         name,
							TypeExpr:     "*" + typeName, // Use entity type instead of dto
							IsSimple:     false,
							IsFKField:    false,
							IsEntityRef:  true,
							OriginalType: typeName,
							GormTag:      fmt.Sprintf("gorm:\"foreignKey:%sID;references:Uid\"", name),
							Comment:      comment,
						})
						continue
					}
				}
			}

			if strings.HasPrefix(tStr, "dto.") || strings.HasPrefix(tStr, "[]") || strings.HasPrefix(tStr, "map[") {
				simple = false
			}

			// Build GORM index tags from EntityConfig.GormIndexes
			gormIndexFieldTags := make(map[string][]string) // Map fieldName -> list of GORM tags for that field
			for _, gormIdx := range e.GormIndexes {
				for i, fieldName := range gormIdx.Fields {
					var tagsForField []string
					indexDef := fmt.Sprintf("%s,priority:%d", gormIdx.Name, i+1)

					tagKey := "index"
					if gormIdx.Unique {
						tagKey = "uniqueIndex"
					}

					tagsForField = append(tagsForField, fmt.Sprintf("%s:%s", tagKey, indexDef))
					gormIndexFieldTags[fieldName] = append(gormIndexFieldTags[fieldName], tagsForField...)

				}
			}

			// Check if this field needs a GORM tag
			gormTag := ""

			// Use explicitly defined GORM index tags from x-go-gorm-index
			// Check Go field name first, then JSON name
			tags, exists := gormIndexFieldTags[name]
			if !exists && jsonName != "" {
				tags, exists = gormIndexFieldTags[jsonName]
			}

			if exists {
				gormTag = fmt.Sprintf("gorm:\"%s\"", strings.Join(tags, ";"))
			} else if slices.Contains(e.UniqueIndexes, name) {
				// Fallback for simple unique indexes (e.g., "uid" uniqueIndex) if not handled by GormIndexes
				gormTag = "gorm:\"uniqueIndex\""

			}

			// If this is a simple alias-to-string type and no explicit gorm tag was set,
			// set a text column to avoid JSONB serialization for enums/aliases.
			if ident, ok := f.Type.(*ast.Ident); ok {
				if base, exists := aliasMap[ident.Name]; exists && base == "string" {
					if gormTag == "" {
						gormTag = "gorm:\"type:text\""
					}
				}
			}

			fields = append(fields, FieldConfig{Name: name, TypeExpr: tStr, IsSimple: simple, GormTag: gormTag, Comment: comment})
		}
		entities[i].Fields = fields
	}

	return entities, nil
}

func extractOpenAPIEntities(doc map[string]any) map[string]EntityConfig {
	entities := make(map[string]EntityConfig)
	comp, ok := doc["components"].(map[string]any)
	if !ok {
		return entities
	}
	schemas, ok := comp["schemas"].(map[string]any)
	if !ok {
		return entities
	}

	for name, raw := range schemas {
		schemaMap, ok := raw.(map[string]any)
		if !ok {
			continue
		}

		val, exists := schemaMap["x-entity"]
		if !exists {
			continue
		}

		if isEntity, ok := val.(bool); !ok || !isEntity {
			continue
		}

		config := EntityConfig{
			Name:       name,
			SoftDelete: true, // Default to true if not specified otherwise
			PKField:    "ID",
		}

		// Extract x-go-gorm-index if present
		if gormIndexes, exists := schemaMap["x-go-gorm-index"]; exists {
			indexData, err := yaml.Marshal(gormIndexes)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Failed to marshal x-go-gorm-index for entity '%s': %v\n", name, err)
				continue
			}
			var indexes []GormIndexConfig
			if err := yaml.Unmarshal(indexData, &indexes); err != nil {
				fmt.Fprintf(os.Stderr, "Failed to unmarshal x-go-gorm-index for entity '%s': %v\n", name, err)
				continue
			}
			config.GormIndexes = indexes
		}
		entities[name] = config
	}
	return entities
}
